#include <iostream> 
#include <vector> 
#include <string>   
using namespace std;


void massiv(vector<long int>& a, string s, int len, int part) {
    string sub; // Временная строка для хранения подстроки из 9 символов

    // k - порядковый номер части числа
    // j - индекс элемента в массиве
    // i - позиция первого символа в текущей подстроке (с конца строки)
    int k = 1, i = len - 9, j = 0;

    while (k <= part) {
        // Извлекаем подстроку длиной 9 символов, начиная с позиции i
        // Если текущая подстрока содержит меньше 9 символов (на первом шаге), берем оставшиеся с начала строки
        sub = i >= 0 ? s.substr(i, 9) : s.substr(0, 9 + i);

        // Преобразуем подстроку в число и сохраняем в массив
        a[j] = stoi(sub.c_str());

        // Увеличиваем индексы для перехода к следующей части числа
        j++;
        k++;
        i -= 9; // Сдвигаем позицию на 9 символов влево
    }
}


// функция преобразования числа в строку с добавлением нулей 
// до 9 разрядов 
string to_str(long int m) {
    string s = to_string(m); // Преобразуем число в строку
    s.insert(0, 9 - s.length(), '0'); // Добавляем ведущие нули, чтобы длина строки стала равной 9
    return s; // Возвращаем строку
}

// Функция для сложения чисел, записанных в виде строк
string add(string s1, string s2) {
    int len1 = s1.length(); // Определяем длину первой строки
    int len2 = s2.length(); // Определяем длину второй строки

    // Выравниваем длины строк добавлением нулей слева к более короткой строке
    if (len1 < len2) {
        s1.insert(0, len2 - len1, '0'); // Добавляем нули к первой строке
    }
    else if (len1 > len2) {
        s2.insert(0, len1 - len2, '0'); // Добавляем нули ко второй строке
    }

    int len = s1.length(); // Итоговая длина строк после добавления нулей

    // Определяем количество частей длиной 9 символов
    int part = len % 9 == 0 ? len / 9 : len / 9 + 1;

    // Создаем векторы для хранения частей чисел и результата с учетом дополнительного разряда
    vector<long int> a(part + 1, 0);
    vector<long int> b(part + 1, 0);
    vector<long int> c(part + 1, 0);

    // Вызываем функцию, преобразующую строки в массивы чисел (по частям)
    massiv(a, s1, len, part);
    massiv(b, s2, len, part);

    // Инициализируем переменную для хранения "переноса" разряда
    int ost = 0;

    // Складываем числа по частям, с учетом переноса разряда
    for (int i = 0; i <= part; i++) {
        // Складываем соответствующие части чисел, добавляем перенос
        c[i] = (a[i] + b[i] + ost) % 1000000000; // Берем остаток от деления на 1 миллиард
        ost = (a[i] + b[i] + ost) / 1000000000; // Вычисляем новый перенос
    }

    string konch; // Инициализируем строку для формирования итогового числа

    // Формируем результат, преобразуя массив чисел обратно в строку
    for (int i = part; i >= 0; i--) {
        konch += to_str(c[i]); // Добавляем каждую часть результата в итоговую строку
    }

    // Удаляем ведущие нули из итоговой строки
    while (konch.substr(0, 1) == "0") {
        konch.erase(konch.find("0"), 1); // Удаляем первый встреченный ноль
    }

    return konch; // Возвращаем итоговую строку
}


//вспомогательная функция для вычитания
void difference(vector <long int> x, vector <long int> y, vector <long int>& z, int part) {
    for (int i = 0; i < part; i++) { // проход по всем разрядам числа, начиная с последнего 
        z[i] = x[i] - y[i];
        if (z[i] < 0) {
            z[i] += 1000000000;
            x[i + 1]--;//занимаем разряд 
        }
    }
}


//функция для вычитания чисел записанных в типе string
string difference_q(string s1, string s2) {
    int len1 = s1.length();
    int len2 = s2.length();
    // добавляем нули слева к меньшей подстроке 
    int k = 3; //если числа равны  
    if (len1 < len2) {
        s1.insert(0, len2 - len1, '0');
        k = 2; // второе число больше 
    }
    else
        if (len1 > len2) {
            s2.insert(0, len1 - len2, '0');
            k = 1; // первое число больше 
        }
        else { // длины чисел равны     
            for (int i = 0; i < len1; i++) { // поразрядное сравнение весов чисел 
                if (s1[i] > s2[i]) { // если разряд первого числа больше 
                    k = 1; // значит первое число длиннее второго 
                    break; // выход из цикла for 
                }
                if (s2[i] > s1[i]) {  // если разряд второго числа больше 
                    k = 2; // значит второе число длиннее первого 
                    break; // выход из цикла for 
                }
            } // конец for 
        }
    string finum;
    if (k == 3) { // ни разу не попали в if в предыдущем цикле 
        finum = "0";
        return finum;
    }
    else {
        int len = s1.length();  // Вычисляем итоговую длину строк (они уже выровнены по длине)

        // Определяем количество "частей", на которые делим строки по 9 символов для удобства обработки
        int part = len % 9 == 0 ? len / 9 : len / 9 + 1;

        // Создаем и инициализируем векторы, заполняя их нулями. 
        // a и b будут содержать числа, представленные строками s1 и s2, 
        // c будет содержать результат разности
        vector<long int> a(part, 0);
        vector<long int> b(part, 0);
        vector<long int> c(part, 0);

        // Вызываем функцию для разделения строк на части и занесения их в массивы a и b
        massiv(a, s1, len, part);
        massiv(b, s2, len, part);

        // Выполняем операцию разности в зависимости от значения k
        // Если k == 1, выполняется a - b; если k != 1, то наоборот (b - a)
        if (k == 1)
            difference(a, b, c, part);
        else
            difference(b, a, c, part);

        // Если k == 2, в результат добавляется знак "-" для обозначения отрицательного числа
        if (k == 2)
            finum = "-";

        // Формируем итоговую строку, проходя по массиву c (результат разности), начиная с конца
        for (int i = part - 1; i >= 0; i--) {
            finum += to_str(c[i]);  // Преобразуем каждую часть в строку и добавляем к результату
        }

        // Удаляем ведущие нули из строки результата (если они есть)
        while (finum.substr(0, 1) == "0") {
            finum.erase(finum.find("0"), 1);
        }

        return finum;  // Возвращаем результирующую строку
    }

}

// функция для умножения
string multyply(string a, string b) {
    string ans; // Инициализируем строку для хранения результата умножения

    // Перебираем цикл от 1 до численного значения строки b
    // (требуется умножить a на значение b)
    for (int i = 1; i <= stoi(b); i++) {
        ans = add(ans, a); // Прибавляем строку a к результату для имитации умножения
    }

    return ans; // Возвращаем итоговый результат умножения
}

int main() {
    setlocale(LC_ALL, "Russian");
    //Ввод числа с консоли
    string big_number;
    cout << "Введите число более 40 разрядов:" << endl;
    cin >> big_number; cout << endl;

    //Проверка на корректность введенного числа
    if (big_number.substr(0, 1) == "-") {
        cout << "Дружище, давай натуральное число";
        return 0;
    }
    else if (big_number.substr(0, 1) == "0") {
        cout << "Друже, числа не начинаются с '0'. давай по новой";
        return 0;
    }

    //массив для проверки отсутствия в числе символов,
    //не являющимися цифрами
    vector<char> nums{ 0,1,2,3,4,5,6,7,8,9 };

    size_t found = big_number.find_first_not_of("1234567890");
    if (found != string::npos) {
        cout << "бро, давай онли циферки, без букав и символов плииииз" << endl;
        return 0;
    }

    if (big_number.length() < 40) {
        cout << "'Введите число более 40 разрядов' для кого написано?";
        return 0;
    }

    bool even = big_number.size() % 2 == 0; // Проверяем, чётное ли число
    vector<string> pairs;
    for (int i = 0; i <= big_number.size(); i += 2) {
        if (even)
            pairs.push_back(big_number.substr(i, 2)); // Если число чётное, разбиваем его на пары
        else {
            pairs.push_back("0" + big_number.substr(i, 1)); // Если нечётное, добавляем 0 перед первой цифрой
            even = true; // Устанавливаем флаг для дальнейшего чётного деления
            i--; // Корректируем счётчик
        }
    }

    string ans, fstnumsq;
    // Обработка первой пары цифр числа
    // Определяем наибольшее целое число, квадрат которого меньше или равен значению первой пары цифр
    for (int i = 1; i <= 9; i++) {
        if (i * i <= stoi(pairs[0])) {
            ans = to_string(i); // Сохраняем текущее число как часть ответа
            fstnumsq = to_string(i * i); // Сохраняем его квадрат как результат вычисления

        }
    }

    cout << "Квадратный корень: " << endl << ans; // Выводим найденное значение
    string resdiff, subtr, plusans, currsubtr, fstmult;
    resdiff = difference_q(pairs[0], fstnumsq); // Вычисляем остаток после вычитания первой пары
    for (int i = 1; i < pairs.size() - 1; i++) {
        resdiff += pairs[i]; // Добавляем к остатку следующую пару цифр
        string partfstmult = multyply(ans, "2"); // Удваиваем текущий ответ
        // Находим цифру, которая при добавлении к удвоенному произведению текущего ответа 
        // и умножении на неё же даст число, меньшее или равное текущему остатку
        for (int j = 1; j <= 9; j++) {
            fstmult = partfstmult + to_string(j); // Формируем возможное частичное произведение
            currsubtr = multyply(fstmult, to_string(j)); // Рассчитываем текущую часть для вычитания
            if (j == 1 & difference_q(resdiff, currsubtr).substr(0, 1) == "-") {
                // Если результат вычитания отрицательный уже при единице, то:
                subtr = "0"; // Вычитаем ноль 
                plusans = "0"; // Дописываем ноль к ответу
                break; // Выходим из цикла
            }
            else if ((difference_q(resdiff, currsubtr)).substr(0, 1) != "-") {
                // Если результат вычитания не отрицательный:
                subtr = currsubtr; // Приравниваем текущее вычитание к конечному вычитанию
                plusans = to_string(j); // Записываем в переменную текущую цифру
            }

        }
        resdiff = difference_q(resdiff, subtr); // новый результат вычитания
        ans += plusans; //дописываем к ответу найденное значение
        cout << plusans; //выводим новый разряд
    }
    if (resdiff != "0") cout << ","; // если остаток не равен нулю, выводим запятую для дробной части
    while (resdiff != "0") {
        resdiff += "00"; // добавляем "00" к остатку для расчета следующей цифры после запятой
        string partfstmult = multyply(ans, "2"); // удваиваем текущий ответ
        for (int j = 1; j <= 9; j++) {
            fstmult = partfstmult + to_string(j); // формируем возможное частичное произведение
            currsubtr = multyply(fstmult, to_string(j)); // рассчитываем текущую часть, подлежащую вычитанию
            if (j == 1 & difference_q(resdiff, currsubtr).substr(0, 1) == "-") {
                // если первое возможное вычитание даёт отрицательный результат, оставляем ноль
                subtr = "0";
                plusans = "0";
            }
            else if ((difference_q(resdiff, currsubtr)).substr(0, 1) != "-") {
                // если вычитание не даёт отрицательный результат, фиксируем текущие значения
                subtr = currsubtr;
                plusans = to_string(j);
            }

        }
        resdiff = difference_q(resdiff, subtr); // обновляем результат вычитания
        ans += plusans; // добавляем к ответу найденное значение
        cout << plusans; // выводим текущий разряд
        int cntzero; // счётчик числа нулей подряд после запятой в ответе
        if (plusans == "0") cntzero++; // увеличиваем счётчик, если очередной разряд равен нулю
        else cntzero = 0; // обнуляем счётчик, если разряд отличный от нуля
        if (cntzero == 32) break; // завершаем цикл, если подряд 32 нуля
    }

}
